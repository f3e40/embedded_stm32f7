// autogenerated

use volatile;
use bit_field::BitField;

# [ doc = "USB on the go high speed" ]
# [ repr ( C ) ]
pub struct OtgHsGlobal {
    # [ doc = "0x00 - OTG_HS control and status register" ]
    pub otg_hs_gotgctl: volatile::ReadWrite<OtgHsGotgctl>,
    # [ doc = "0x04 - OTG_HS interrupt register" ]
    pub otg_hs_gotgint: volatile::ReadWrite<OtgHsGotgint>,
    # [ doc = "0x08 - OTG_HS AHB configuration register" ]
    pub otg_hs_gahbcfg: volatile::ReadWrite<OtgHsGahbcfg>,
    # [ doc = "0x0c - OTG_HS USB configuration register" ]
    pub otg_hs_gusbcfg: volatile::ReadWrite<OtgHsGusbcfg>,
    # [ doc = "0x10 - OTG_HS reset register" ]
    pub otg_hs_grstctl: volatile::ReadWrite<OtgHsGrstctl>,
    # [ doc = "0x14 - OTG_HS core interrupt register" ]
    pub otg_hs_gintsts: volatile::ReadWrite<OtgHsGintsts>,
    # [ doc = "0x18 - OTG_HS interrupt mask register" ]
    pub otg_hs_gintmsk: volatile::ReadWrite<OtgHsGintmsk>,
    # [ doc = "0x1c - OTG_HS Receive status debug read register (host mode)" ]
    pub otg_hs_grxstsr_host: volatile::ReadOnly<OtgHsGrxstsrHost>,
    # [ doc = "0x20 - OTG_HS status read and pop register (host mode)" ]
    pub otg_hs_grxstsp_host: volatile::ReadOnly<OtgHsGrxstspHost>,
    # [ doc = "0x24 - OTG_HS Receive FIFO size register" ]
    pub otg_hs_grxfsiz: volatile::ReadWrite<OtgHsGrxfsiz>,
    # [ doc = "0x28 - OTG_HS nonperiodic transmit FIFO size register (host mode)" ]
    pub otg_hs_hnptxfsiz_host: volatile::ReadWrite<OtgHsHnptxfsizHost>,
    # [ doc = "0x2c - OTG_HS nonperiodic transmit FIFO/queue status register" ]
    pub otg_hs_gnptxsts: volatile::ReadOnly<OtgHsGnptxsts>,
    _reserved0: [u8; 8usize],
    # [ doc = "0x38 - OTG_HS general core configuration register" ]
    pub otg_hs_gccfg: volatile::ReadWrite<OtgHsGccfg>,
    # [ doc = "0x3c - OTG_HS core ID register" ]
    pub otg_hs_cid: volatile::ReadWrite<OtgHsCid>,
    _reserved1: [u8; 20usize],
    # [ doc = "0x54 - OTG core LPM configuration register" ]
    pub otg_hs_glpmcfg: volatile::ReadWrite<OtgHsGlpmcfg>,
    _reserved2: [u8; 168usize],
    # [ doc = "0x100 - OTG_HS Host periodic transmit FIFO size register" ]
    pub otg_hs_hptxfsiz: volatile::ReadWrite<OtgHsHptxfsiz>,
    # [ doc = "0x104 - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf1: volatile::ReadWrite<OtgHsDieptxf1>,
    # [ doc = "0x108 - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf2: volatile::ReadWrite<OtgHsDieptxf2>,
    _reserved3: [u8; 16usize],
    # [ doc = "0x11c - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf3: volatile::ReadWrite<OtgHsDieptxf3>,
    # [ doc = "0x120 - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf4: volatile::ReadWrite<OtgHsDieptxf4>,
    # [ doc = "0x124 - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf5: volatile::ReadWrite<OtgHsDieptxf5>,
    # [ doc = "0x128 - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf6: volatile::ReadWrite<OtgHsDieptxf6>,
    # [ doc = "0x12c - OTG_HS device IN endpoint transmit FIFO size register" ]
    pub otg_hs_dieptxf7: volatile::ReadWrite<OtgHsDieptxf7>,
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGotgctl {
    pub bits: u32,
}

impl OtgHsGotgctl {
    # [ doc = "Bit 0 - Session request success" ]
    pub fn srqscs(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Session request" ]
    pub fn srq(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 8 - Host negotiation success" ]
    pub fn hngscs(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - HNP request" ]
    pub fn hnprq(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 10 - Host set HNP enable" ]
    pub fn hshnpen(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - Device HNP enabled" ]
    pub fn dhnpen(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 16 - Connector ID status" ]
    pub fn cidsts(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Long/short debounce time" ]
    pub fn dbct(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - A-session valid" ]
    pub fn asvld(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - B-session valid" ]
    pub fn bsvld(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 12 - Embedded host enable" ]
    pub fn ehen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
}

impl Default for OtgHsGotgctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGotgctl { bits: 2048u32 }
    }
}

impl OtgHsGotgctl {
    # [ doc = "Bit 1 - Session request" ]
    pub fn set_srq(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 9 - HNP request" ]
    pub fn set_hnprq(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 10 - Host set HNP enable" ]
    pub fn set_hshnpen(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - Device HNP enabled" ]
    pub fn set_dhnpen(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - Embedded host enable" ]
    pub fn set_ehen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGotgint {
    pub bits: u32,
}

impl OtgHsGotgint {
    # [ doc = "Bit 2 - Session end detected" ]
    pub fn sedet(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 8 - Session request success status change" ]
    pub fn srsschg(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - Host negotiation success status change" ]
    pub fn hnsschg(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bit 17 - Host negotiation detected" ]
    pub fn hngdet(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - A-device timeout change" ]
    pub fn adtochg(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Debounce done" ]
    pub fn dbcdne(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - ID input pin changed" ]
    pub fn idchng(&self) -> bool {
        self.bits.get_bit(20u8)
    }
}

impl Default for OtgHsGotgint {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGotgint { bits: 0u32 }
    }
}

impl OtgHsGotgint {
    # [ doc = "Bit 2 - Session end detected" ]
    pub fn set_sedet(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 8 - Session request success status change" ]
    pub fn set_srsschg(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - Host negotiation success status change" ]
    pub fn set_hnsschg(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bit 17 - Host negotiation detected" ]
    pub fn set_hngdet(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - A-device timeout change" ]
    pub fn set_adtochg(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Debounce done" ]
    pub fn set_dbcdne(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - ID input pin changed" ]
    pub fn set_idchng(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGahbcfg {
    pub bits: u32,
}

impl OtgHsGahbcfg {
    # [ doc = "Bit 0 - Global interrupt mask" ]
    pub fn gint(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bits 1:4 - Burst length/type" ]
    pub fn hbstlen(&self) -> u8 {
        self.bits.get_range(1u8..5u8) as u8
    }
    # [ doc = "Bit 5 - DMA enable" ]
    pub fn dmaen(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 7 - TxFIFO empty level" ]
    pub fn txfelvl(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 8 - Periodic TxFIFO empty level" ]
    pub fn ptxfelvl(&self) -> bool {
        self.bits.get_bit(8u8)
    }
}

impl Default for OtgHsGahbcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGahbcfg { bits: 0u32 }
    }
}

impl OtgHsGahbcfg {
    # [ doc = "Bit 0 - Global interrupt mask" ]
    pub fn set_gint(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bits 1:4 - Burst length/type" ]
    pub fn set_hbstlen(&mut self, value: u8) {
        self.bits.set_range(1u8..5u8, value as u32);
    }
    # [ doc = "Bit 5 - DMA enable" ]
    pub fn set_dmaen(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 7 - TxFIFO empty level" ]
    pub fn set_txfelvl(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 8 - Periodic TxFIFO empty level" ]
    pub fn set_ptxfelvl(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGusbcfg {
    pub bits: u32,
}

impl OtgHsGusbcfg {
    # [ doc = "Bits 0:2 - FS timeout calibration" ]
    pub fn tocal(&self) -> u8 {
        self.bits.get_range(0u8..3u8) as u8
    }
    # [ doc = "Bit 8 - SRP-capable" ]
    pub fn srpcap(&self) -> bool {
        self.bits.get_bit(8u8)
    }
    # [ doc = "Bit 9 - HNP-capable" ]
    pub fn hnpcap(&self) -> bool {
        self.bits.get_bit(9u8)
    }
    # [ doc = "Bits 10:13 - USB turnaround time" ]
    pub fn trdt(&self) -> u8 {
        self.bits.get_range(10u8..14u8) as u8
    }
    # [ doc = "Bit 15 - PHY Low-power clock select" ]
    pub fn phylpcs(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 17 - ULPI FS/LS select" ]
    pub fn ulpifsls(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - ULPI Auto-resume" ]
    pub fn ulpiar(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - ULPI Clock SuspendM" ]
    pub fn ulpicsm(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - ULPI External VBUS Drive" ]
    pub fn ulpievbusd(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - ULPI external VBUS indicator" ]
    pub fn ulpievbusi(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - TermSel DLine pulsing selection" ]
    pub fn tsdps(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 23 - Indicator complement" ]
    pub fn pcci(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 24 - Indicator pass through" ]
    pub fn ptci(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - ULPI interface protect disable" ]
    pub fn ulpiipd(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 29 - Forced host mode" ]
    pub fn fhmod(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Forced peripheral mode" ]
    pub fn fdmod(&self) -> bool {
        self.bits.get_bit(30u8)
    }
}

impl Default for OtgHsGusbcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGusbcfg { bits: 2560u32 }
    }
}

impl OtgHsGusbcfg {
    # [ doc = "Bits 0:2 - FS timeout calibration" ]
    pub fn set_tocal(&mut self, value: u8) {
        self.bits.set_range(0u8..3u8, value as u32);
    }
    # [ doc = "Bit 6 - USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select" ]
    pub fn set_physel(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 8 - SRP-capable" ]
    pub fn set_srpcap(&mut self, value: bool) {
        self.bits.set_bit(8u8, value);
    }
    # [ doc = "Bit 9 - HNP-capable" ]
    pub fn set_hnpcap(&mut self, value: bool) {
        self.bits.set_bit(9u8, value);
    }
    # [ doc = "Bits 10:13 - USB turnaround time" ]
    pub fn set_trdt(&mut self, value: u8) {
        self.bits.set_range(10u8..14u8, value as u32);
    }
    # [ doc = "Bit 15 - PHY Low-power clock select" ]
    pub fn set_phylpcs(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 17 - ULPI FS/LS select" ]
    pub fn set_ulpifsls(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - ULPI Auto-resume" ]
    pub fn set_ulpiar(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - ULPI Clock SuspendM" ]
    pub fn set_ulpicsm(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - ULPI External VBUS Drive" ]
    pub fn set_ulpievbusd(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - ULPI external VBUS indicator" ]
    pub fn set_ulpievbusi(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - TermSel DLine pulsing selection" ]
    pub fn set_tsdps(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 23 - Indicator complement" ]
    pub fn set_pcci(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 24 - Indicator pass through" ]
    pub fn set_ptci(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 25 - ULPI interface protect disable" ]
    pub fn set_ulpiipd(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 29 - Forced host mode" ]
    pub fn set_fhmod(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Forced peripheral mode" ]
    pub fn set_fdmod(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrstctl {
    pub bits: u32,
}

impl OtgHsGrstctl {
    # [ doc = "Bit 0 - Core soft reset" ]
    pub fn csrst(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - HCLK soft reset" ]
    pub fn hsrst(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Host frame counter reset" ]
    pub fn fcrst(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 4 - RxFIFO flush" ]
    pub fn rxfflsh(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - TxFIFO flush" ]
    pub fn txfflsh(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bits 6:10 - TxFIFO number" ]
    pub fn txfnum(&self) -> u8 {
        self.bits.get_range(6u8..11u8) as u8
    }
    # [ doc = "Bit 31 - AHB master idle" ]
    pub fn ahbidl(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 30 - DMA request signal enabled for USB OTG HS" ]
    pub fn dmareq(&self) -> bool {
        self.bits.get_bit(30u8)
    }
}

impl Default for OtgHsGrstctl {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrstctl { bits: 536870912u32 }
    }
}

impl OtgHsGrstctl {
    # [ doc = "Bit 0 - Core soft reset" ]
    pub fn set_csrst(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - HCLK soft reset" ]
    pub fn set_hsrst(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Host frame counter reset" ]
    pub fn set_fcrst(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 4 - RxFIFO flush" ]
    pub fn set_rxfflsh(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - TxFIFO flush" ]
    pub fn set_txfflsh(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bits 6:10 - TxFIFO number" ]
    pub fn set_txfnum(&mut self, value: u8) {
        self.bits.set_range(6u8..11u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGintsts {
    pub bits: u32,
}

impl OtgHsGintsts {
    # [ doc = "Bit 0 - Current mode of operation" ]
    pub fn cmod(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Mode mismatch interrupt" ]
    pub fn mmis(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - OTG interrupt" ]
    pub fn otgint(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Start of frame" ]
    pub fn sof(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - RxFIFO nonempty" ]
    pub fn rxflvl(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Nonperiodic TxFIFO empty" ]
    pub fn nptxfe(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Global IN nonperiodic NAK effective" ]
    pub fn ginakeff(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Global OUT NAK effective" ]
    pub fn boutnakeff(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 10 - Early suspend" ]
    pub fn esusp(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - USB suspend" ]
    pub fn usbsusp(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - USB reset" ]
    pub fn usbrst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Enumeration done" ]
    pub fn enumdne(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt" ]
    pub fn isoodrp(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt" ]
    pub fn eopf(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 18 - IN endpoint interrupt" ]
    pub fn iepint(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - OUT endpoint interrupt" ]
    pub fn oepint(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer" ]
    pub fn iisoixfr(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer" ]
    pub fn pxfr_incompisoout(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - Data fetch suspended" ]
    pub fn datafsusp(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 24 - Host port interrupt" ]
    pub fn hprtint(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - Host channels interrupt" ]
    pub fn hcint(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty" ]
    pub fn ptxfe(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Connector ID status change" ]
    pub fn cidschg(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt" ]
    pub fn discint(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt" ]
    pub fn srqint(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt" ]
    pub fn wkuint(&self) -> bool {
        self.bits.get_bit(31u8)
    }
}

impl Default for OtgHsGintsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGintsts { bits: 67108896u32 }
    }
}

impl OtgHsGintsts {
    # [ doc = "Bit 1 - Mode mismatch interrupt" ]
    pub fn set_mmis(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 3 - Start of frame" ]
    pub fn set_sof(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 10 - Early suspend" ]
    pub fn set_esusp(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - USB suspend" ]
    pub fn set_usbsusp(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - USB reset" ]
    pub fn set_usbrst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Enumeration done" ]
    pub fn set_enumdne(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt" ]
    pub fn set_isoodrp(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt" ]
    pub fn set_eopf(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer" ]
    pub fn set_iisoixfr(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer" ]
    pub fn set_pxfr_incompisoout(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - Data fetch suspended" ]
    pub fn set_datafsusp(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 28 - Connector ID status change" ]
    pub fn set_cidschg(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt" ]
    pub fn set_discint(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt" ]
    pub fn set_srqint(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt" ]
    pub fn set_wkuint(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGintmsk {
    pub bits: u32,
}

impl OtgHsGintmsk {
    # [ doc = "Bit 1 - Mode mismatch interrupt mask" ]
    pub fn mmism(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - OTG interrupt mask" ]
    pub fn otgint(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - Start of frame mask" ]
    pub fn sofm(&self) -> bool {
        self.bits.get_bit(3u8)
    }
    # [ doc = "Bit 4 - Receive FIFO nonempty mask" ]
    pub fn rxflvlm(&self) -> bool {
        self.bits.get_bit(4u8)
    }
    # [ doc = "Bit 5 - Nonperiodic TxFIFO empty mask" ]
    pub fn nptxfem(&self) -> bool {
        self.bits.get_bit(5u8)
    }
    # [ doc = "Bit 6 - Global nonperiodic IN NAK effective mask" ]
    pub fn ginakeffm(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - Global OUT NAK effective mask" ]
    pub fn gonakeffm(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bit 10 - Early suspend mask" ]
    pub fn esuspm(&self) -> bool {
        self.bits.get_bit(10u8)
    }
    # [ doc = "Bit 11 - USB suspend mask" ]
    pub fn usbsuspm(&self) -> bool {
        self.bits.get_bit(11u8)
    }
    # [ doc = "Bit 12 - USB reset mask" ]
    pub fn usbrst(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bit 13 - Enumeration done mask" ]
    pub fn enumdnem(&self) -> bool {
        self.bits.get_bit(13u8)
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask" ]
    pub fn isoodrpm(&self) -> bool {
        self.bits.get_bit(14u8)
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt mask" ]
    pub fn eopfm(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 18 - IN endpoints interrupt mask" ]
    pub fn iepint(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - OUT endpoints interrupt mask" ]
    pub fn oepint(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer mask" ]
    pub fn iisoixfrm(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer mask" ]
    pub fn pxfrm_iisooxfrm(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 22 - Data fetch suspended mask" ]
    pub fn fsuspm(&self) -> bool {
        self.bits.get_bit(22u8)
    }
    # [ doc = "Bit 24 - Host port interrupt mask" ]
    pub fn prtim(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bit 25 - Host channels interrupt mask" ]
    pub fn hcim(&self) -> bool {
        self.bits.get_bit(25u8)
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty mask" ]
    pub fn ptxfem(&self) -> bool {
        self.bits.get_bit(26u8)
    }
    # [ doc = "Bit 28 - Connector ID status change mask" ]
    pub fn cidschgm(&self) -> bool {
        self.bits.get_bit(28u8)
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt mask" ]
    pub fn discint(&self) -> bool {
        self.bits.get_bit(29u8)
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt mask" ]
    pub fn srqim(&self) -> bool {
        self.bits.get_bit(30u8)
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt mask" ]
    pub fn wuim(&self) -> bool {
        self.bits.get_bit(31u8)
    }
    # [ doc = "Bit 23 - Reset detected interrupt mask" ]
    pub fn rstde(&self) -> bool {
        self.bits.get_bit(23u8)
    }
    # [ doc = "Bit 27 - LPM interrupt mask" ]
    pub fn lpmintm(&self) -> bool {
        self.bits.get_bit(27u8)
    }
}

impl Default for OtgHsGintmsk {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGintmsk { bits: 0u32 }
    }
}

impl OtgHsGintmsk {
    # [ doc = "Bit 1 - Mode mismatch interrupt mask" ]
    pub fn set_mmism(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - OTG interrupt mask" ]
    pub fn set_otgint(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - Start of frame mask" ]
    pub fn set_sofm(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
    # [ doc = "Bit 4 - Receive FIFO nonempty mask" ]
    pub fn set_rxflvlm(&mut self, value: bool) {
        self.bits.set_bit(4u8, value);
    }
    # [ doc = "Bit 5 - Nonperiodic TxFIFO empty mask" ]
    pub fn set_nptxfem(&mut self, value: bool) {
        self.bits.set_bit(5u8, value);
    }
    # [ doc = "Bit 6 - Global nonperiodic IN NAK effective mask" ]
    pub fn set_ginakeffm(&mut self, value: bool) {
        self.bits.set_bit(6u8, value);
    }
    # [ doc = "Bit 7 - Global OUT NAK effective mask" ]
    pub fn set_gonakeffm(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bit 10 - Early suspend mask" ]
    pub fn set_esuspm(&mut self, value: bool) {
        self.bits.set_bit(10u8, value);
    }
    # [ doc = "Bit 11 - USB suspend mask" ]
    pub fn set_usbsuspm(&mut self, value: bool) {
        self.bits.set_bit(11u8, value);
    }
    # [ doc = "Bit 12 - USB reset mask" ]
    pub fn set_usbrst(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bit 13 - Enumeration done mask" ]
    pub fn set_enumdnem(&mut self, value: bool) {
        self.bits.set_bit(13u8, value);
    }
    # [ doc = "Bit 14 - Isochronous OUT packet dropped interrupt mask" ]
    pub fn set_isoodrpm(&mut self, value: bool) {
        self.bits.set_bit(14u8, value);
    }
    # [ doc = "Bit 15 - End of periodic frame interrupt mask" ]
    pub fn set_eopfm(&mut self, value: bool) {
        self.bits.set_bit(15u8, value);
    }
    # [ doc = "Bit 18 - IN endpoints interrupt mask" ]
    pub fn set_iepint(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - OUT endpoints interrupt mask" ]
    pub fn set_oepint(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Incomplete isochronous IN transfer mask" ]
    pub fn set_iisoixfrm(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - Incomplete periodic transfer mask" ]
    pub fn set_pxfrm_iisooxfrm(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 22 - Data fetch suspended mask" ]
    pub fn set_fsuspm(&mut self, value: bool) {
        self.bits.set_bit(22u8, value);
    }
    # [ doc = "Bit 25 - Host channels interrupt mask" ]
    pub fn set_hcim(&mut self, value: bool) {
        self.bits.set_bit(25u8, value);
    }
    # [ doc = "Bit 26 - Periodic TxFIFO empty mask" ]
    pub fn set_ptxfem(&mut self, value: bool) {
        self.bits.set_bit(26u8, value);
    }
    # [ doc = "Bit 28 - Connector ID status change mask" ]
    pub fn set_cidschgm(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
    # [ doc = "Bit 29 - Disconnect detected interrupt mask" ]
    pub fn set_discint(&mut self, value: bool) {
        self.bits.set_bit(29u8, value);
    }
    # [ doc = "Bit 30 - Session request/new session detected interrupt mask" ]
    pub fn set_srqim(&mut self, value: bool) {
        self.bits.set_bit(30u8, value);
    }
    # [ doc = "Bit 31 - Resume/remote wakeup detected interrupt mask" ]
    pub fn set_wuim(&mut self, value: bool) {
        self.bits.set_bit(31u8, value);
    }
    # [ doc = "Bit 23 - Reset detected interrupt mask" ]
    pub fn set_rstde(&mut self, value: bool) {
        self.bits.set_bit(23u8, value);
    }
    # [ doc = "Bit 27 - LPM interrupt mask" ]
    pub fn set_lpmintm(&mut self, value: bool) {
        self.bits.set_bit(27u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrxstsrHost {
    pub bits: u32,
}

impl OtgHsGrxstsrHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn chnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
}

impl Default for OtgHsGrxstsrHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrxstsrHost { bits: 0u32 }
    }
}

impl OtgHsGrxstsrHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn set_chnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrxstsrDevice {
    pub bits: u32,
}

impl OtgHsGrxstsrDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn frmnum(&self) -> u8 {
        self.bits.get_range(21u8..25u8) as u8
    }
}

impl Default for OtgHsGrxstsrDevice {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrxstsrDevice { bits: 0u32 }
    }
}

impl OtgHsGrxstsrDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn set_frmnum(&mut self, value: u8) {
        self.bits.set_range(21u8..25u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrxstspHost {
    pub bits: u32,
}

impl OtgHsGrxstspHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn chnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
}

impl Default for OtgHsGrxstspHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrxstspHost { bits: 0u32 }
    }
}

impl OtgHsGrxstspHost {
    # [ doc = "Bits 0:3 - Channel number" ]
    pub fn set_chnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrxstspDevice {
    pub bits: u32,
}

impl OtgHsGrxstspDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn epnum(&self) -> u8 {
        self.bits.get_range(0u8..4u8) as u8
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn bcnt(&self) -> u16 {
        self.bits.get_range(4u8..15u8) as u16
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn dpid(&self) -> u8 {
        self.bits.get_range(15u8..17u8) as u8
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn pktsts(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn frmnum(&self) -> u8 {
        self.bits.get_range(21u8..25u8) as u8
    }
}

impl Default for OtgHsGrxstspDevice {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrxstspDevice { bits: 0u32 }
    }
}

impl OtgHsGrxstspDevice {
    # [ doc = "Bits 0:3 - Endpoint number" ]
    pub fn set_epnum(&mut self, value: u8) {
        self.bits.set_range(0u8..4u8, value as u32);
    }
    # [ doc = "Bits 4:14 - Byte count" ]
    pub fn set_bcnt(&mut self, value: u16) {
        self.bits.set_range(4u8..15u8, value as u32);
    }
    # [ doc = "Bits 15:16 - Data PID" ]
    pub fn set_dpid(&mut self, value: u8) {
        self.bits.set_range(15u8..17u8, value as u32);
    }
    # [ doc = "Bits 17:20 - Packet status" ]
    pub fn set_pktsts(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:24 - Frame number" ]
    pub fn set_frmnum(&mut self, value: u8) {
        self.bits.set_range(21u8..25u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGrxfsiz {
    pub bits: u32,
}

impl OtgHsGrxfsiz {
    # [ doc = "Bits 0:15 - RxFIFO depth" ]
    pub fn rxfd(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
}

impl Default for OtgHsGrxfsiz {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGrxfsiz { bits: 512u32 }
    }
}

impl OtgHsGrxfsiz {
    # [ doc = "Bits 0:15 - RxFIFO depth" ]
    pub fn set_rxfd(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHnptxfsizHost {
    pub bits: u32,
}

impl OtgHsHnptxfsizHost {
    # [ doc = "Bits 0:15 - Nonperiodic transmit RAM start address" ]
    pub fn nptxfsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Nonperiodic TxFIFO depth" ]
    pub fn nptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsHnptxfsizHost {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHnptxfsizHost { bits: 512u32 }
    }
}

impl OtgHsHnptxfsizHost {
    # [ doc = "Bits 0:15 - Nonperiodic transmit RAM start address" ]
    pub fn set_nptxfsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Nonperiodic TxFIFO depth" ]
    pub fn set_nptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf0Device {
    pub bits: u32,
}

impl OtgHsDieptxf0Device {
    # [ doc = "Bits 0:15 - Endpoint 0 transmit RAM start address" ]
    pub fn tx0fsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Endpoint 0 TxFIFO depth" ]
    pub fn tx0fd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf0Device {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf0Device { bits: 512u32 }
    }
}

impl OtgHsDieptxf0Device {
    # [ doc = "Bits 0:15 - Endpoint 0 transmit RAM start address" ]
    pub fn set_tx0fsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Endpoint 0 TxFIFO depth" ]
    pub fn set_tx0fd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGnptxsts {
    pub bits: u32,
}

impl OtgHsGnptxsts {
    # [ doc = "Bits 0:15 - Nonperiodic TxFIFO space available" ]
    pub fn nptxfsav(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:23 - Nonperiodic transmit request queue space available" ]
    pub fn nptqxsav(&self) -> u8 {
        self.bits.get_range(16u8..24u8) as u8
    }
    # [ doc = "Bits 24:30 - Top of the nonperiodic transmit request queue" ]
    pub fn nptxqtop(&self) -> u8 {
        self.bits.get_range(24u8..31u8) as u8
    }
}

impl Default for OtgHsGnptxsts {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGnptxsts { bits: 524800u32 }
    }
}

impl OtgHsGnptxsts {
    # [ doc = "Bits 0:15 - Nonperiodic TxFIFO space available" ]
    pub fn set_nptxfsav(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:23 - Nonperiodic transmit request queue space available" ]
    pub fn set_nptqxsav(&mut self, value: u8) {
        self.bits.set_range(16u8..24u8, value as u32);
    }
    # [ doc = "Bits 24:30 - Top of the nonperiodic transmit request queue" ]
    pub fn set_nptxqtop(&mut self, value: u8) {
        self.bits.set_range(24u8..31u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGccfg {
    pub bits: u32,
}

impl OtgHsGccfg {
    # [ doc = "Bit 16 - Power down" ]
    pub fn pwrdwn(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bit 17 - Battery charging detector (BCD) enable" ]
    pub fn bcden(&self) -> bool {
        self.bits.get_bit(17u8)
    }
    # [ doc = "Bit 18 - Data contact detection (DCD) mode enable" ]
    pub fn dcden(&self) -> bool {
        self.bits.get_bit(18u8)
    }
    # [ doc = "Bit 19 - Primary detection (PD) mode enable" ]
    pub fn pden(&self) -> bool {
        self.bits.get_bit(19u8)
    }
    # [ doc = "Bit 20 - Secondary detection (SD) mode enable" ]
    pub fn sden(&self) -> bool {
        self.bits.get_bit(20u8)
    }
    # [ doc = "Bit 21 - USB VBUS detection enable" ]
    pub fn vbden(&self) -> bool {
        self.bits.get_bit(21u8)
    }
    # [ doc = "Bit 0 - Data contact detection (DCD) status" ]
    pub fn dcdet(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - Primary detection (PD) status" ]
    pub fn pdet(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bit 2 - Secondary detection (SD) status" ]
    pub fn sdet(&self) -> bool {
        self.bits.get_bit(2u8)
    }
    # [ doc = "Bit 3 - DM pull-up detection status" ]
    pub fn ps2det(&self) -> bool {
        self.bits.get_bit(3u8)
    }
}

impl Default for OtgHsGccfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGccfg { bits: 0u32 }
    }
}

impl OtgHsGccfg {
    # [ doc = "Bit 16 - Power down" ]
    pub fn set_pwrdwn(&mut self, value: bool) {
        self.bits.set_bit(16u8, value);
    }
    # [ doc = "Bit 17 - Battery charging detector (BCD) enable" ]
    pub fn set_bcden(&mut self, value: bool) {
        self.bits.set_bit(17u8, value);
    }
    # [ doc = "Bit 18 - Data contact detection (DCD) mode enable" ]
    pub fn set_dcden(&mut self, value: bool) {
        self.bits.set_bit(18u8, value);
    }
    # [ doc = "Bit 19 - Primary detection (PD) mode enable" ]
    pub fn set_pden(&mut self, value: bool) {
        self.bits.set_bit(19u8, value);
    }
    # [ doc = "Bit 20 - Secondary detection (SD) mode enable" ]
    pub fn set_sden(&mut self, value: bool) {
        self.bits.set_bit(20u8, value);
    }
    # [ doc = "Bit 21 - USB VBUS detection enable" ]
    pub fn set_vbden(&mut self, value: bool) {
        self.bits.set_bit(21u8, value);
    }
    # [ doc = "Bit 0 - Data contact detection (DCD) status" ]
    pub fn set_dcdet(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - Primary detection (PD) status" ]
    pub fn set_pdet(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 2 - Secondary detection (SD) status" ]
    pub fn set_sdet(&mut self, value: bool) {
        self.bits.set_bit(2u8, value);
    }
    # [ doc = "Bit 3 - DM pull-up detection status" ]
    pub fn set_ps2det(&mut self, value: bool) {
        self.bits.set_bit(3u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsCid {
    pub bits: u32,
}

impl OtgHsCid {
    # [ doc = "Bits 0:31 - Product ID field" ]
    pub fn product_id(&self) -> u32 {
        self.bits.get_range(0u8..32u8) as u32
    }
}

impl Default for OtgHsCid {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsCid { bits: 4608u32 }
    }
}

impl OtgHsCid {
    # [ doc = "Bits 0:31 - Product ID field" ]
    pub fn set_product_id(&mut self, value: u32) {
        self.bits.set_range(0u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsGlpmcfg {
    pub bits: u32,
}

impl OtgHsGlpmcfg {
    # [ doc = "Bit 0 - LPM support enable" ]
    pub fn lpmen(&self) -> bool {
        self.bits.get_bit(0u8)
    }
    # [ doc = "Bit 1 - LPM token acknowledge enable" ]
    pub fn lpmack(&self) -> bool {
        self.bits.get_bit(1u8)
    }
    # [ doc = "Bits 2:5 - Best effort service latency" ]
    pub fn besl(&self) -> u8 {
        self.bits.get_range(2u8..6u8) as u8
    }
    # [ doc = "Bit 6 - bRemoteWake value" ]
    pub fn remwake(&self) -> bool {
        self.bits.get_bit(6u8)
    }
    # [ doc = "Bit 7 - L1 Shallow Sleep enable" ]
    pub fn l1ssen(&self) -> bool {
        self.bits.get_bit(7u8)
    }
    # [ doc = "Bits 8:11 - BESL threshold" ]
    pub fn beslthrs(&self) -> u8 {
        self.bits.get_range(8u8..12u8) as u8
    }
    # [ doc = "Bit 12 - L1 deep sleep enable" ]
    pub fn l1dsen(&self) -> bool {
        self.bits.get_bit(12u8)
    }
    # [ doc = "Bits 13:14 - LPM response" ]
    pub fn lpmrst(&self) -> u8 {
        self.bits.get_range(13u8..15u8) as u8
    }
    # [ doc = "Bit 15 - Port sleep status" ]
    pub fn slpsts(&self) -> bool {
        self.bits.get_bit(15u8)
    }
    # [ doc = "Bit 16 - Sleep State Resume OK" ]
    pub fn l1rsmok(&self) -> bool {
        self.bits.get_bit(16u8)
    }
    # [ doc = "Bits 17:20 - LPM Channel Index" ]
    pub fn lpmchidx(&self) -> u8 {
        self.bits.get_range(17u8..21u8) as u8
    }
    # [ doc = "Bits 21:23 - LPM retry count" ]
    pub fn lpmrcnt(&self) -> u8 {
        self.bits.get_range(21u8..24u8) as u8
    }
    # [ doc = "Bit 24 - Send LPM transaction" ]
    pub fn sndlpm(&self) -> bool {
        self.bits.get_bit(24u8)
    }
    # [ doc = "Bits 25:27 - LPM retry count status" ]
    pub fn lpmrcntsts(&self) -> u8 {
        self.bits.get_range(25u8..28u8) as u8
    }
    # [ doc = "Bit 28 - Enable best effort service latency" ]
    pub fn enbesl(&self) -> bool {
        self.bits.get_bit(28u8)
    }
}

impl Default for OtgHsGlpmcfg {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsGlpmcfg { bits: 0u32 }
    }
}

impl OtgHsGlpmcfg {
    # [ doc = "Bit 0 - LPM support enable" ]
    pub fn set_lpmen(&mut self, value: bool) {
        self.bits.set_bit(0u8, value);
    }
    # [ doc = "Bit 1 - LPM token acknowledge enable" ]
    pub fn set_lpmack(&mut self, value: bool) {
        self.bits.set_bit(1u8, value);
    }
    # [ doc = "Bit 7 - L1 Shallow Sleep enable" ]
    pub fn set_l1ssen(&mut self, value: bool) {
        self.bits.set_bit(7u8, value);
    }
    # [ doc = "Bits 8:11 - BESL threshold" ]
    pub fn set_beslthrs(&mut self, value: u8) {
        self.bits.set_range(8u8..12u8, value as u32);
    }
    # [ doc = "Bit 12 - L1 deep sleep enable" ]
    pub fn set_l1dsen(&mut self, value: bool) {
        self.bits.set_bit(12u8, value);
    }
    # [ doc = "Bits 17:20 - LPM Channel Index" ]
    pub fn set_lpmchidx(&mut self, value: u8) {
        self.bits.set_range(17u8..21u8, value as u32);
    }
    # [ doc = "Bits 21:23 - LPM retry count" ]
    pub fn set_lpmrcnt(&mut self, value: u8) {
        self.bits.set_range(21u8..24u8, value as u32);
    }
    # [ doc = "Bit 24 - Send LPM transaction" ]
    pub fn set_sndlpm(&mut self, value: bool) {
        self.bits.set_bit(24u8, value);
    }
    # [ doc = "Bit 28 - Enable best effort service latency" ]
    pub fn set_enbesl(&mut self, value: bool) {
        self.bits.set_bit(28u8, value);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsHptxfsiz {
    pub bits: u32,
}

impl OtgHsHptxfsiz {
    # [ doc = "Bits 0:15 - Host periodic TxFIFO start address" ]
    pub fn ptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - Host periodic TxFIFO depth" ]
    pub fn ptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsHptxfsiz {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsHptxfsiz { bits: 33555968u32 }
    }
}

impl OtgHsHptxfsiz {
    # [ doc = "Bits 0:15 - Host periodic TxFIFO start address" ]
    pub fn set_ptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - Host periodic TxFIFO depth" ]
    pub fn set_ptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf1 {
    pub bits: u32,
}

impl OtgHsDieptxf1 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf1 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf1 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf1 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf2 {
    pub bits: u32,
}

impl OtgHsDieptxf2 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf2 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf2 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf2 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf3 {
    pub bits: u32,
}

impl OtgHsDieptxf3 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf3 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf3 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf3 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf4 {
    pub bits: u32,
}

impl OtgHsDieptxf4 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf4 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf4 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf4 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf5 {
    pub bits: u32,
}

impl OtgHsDieptxf5 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf5 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf5 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf5 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf6 {
    pub bits: u32,
}

impl OtgHsDieptxf6 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf6 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf6 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf6 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}

# [ derive ( Debug , Clone , Copy , PartialEq , Eq ) ]
# [ repr ( C ) ]
pub struct OtgHsDieptxf7 {
    pub bits: u32,
}

impl OtgHsDieptxf7 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn ineptxsa(&self) -> u16 {
        self.bits.get_range(0u8..16u8) as u16
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn ineptxfd(&self) -> u16 {
        self.bits.get_range(16u8..32u8) as u16
    }
}

impl Default for OtgHsDieptxf7 {
    # [ doc = r" Reset value" ]
    fn default() -> Self {
        OtgHsDieptxf7 { bits: 33555456u32 }
    }
}

impl OtgHsDieptxf7 {
    # [ doc = "Bits 0:15 - IN endpoint FIFOx transmit RAM start address" ]
    pub fn set_ineptxsa(&mut self, value: u16) {
        self.bits.set_range(0u8..16u8, value as u32);
    }
    # [ doc = "Bits 16:31 - IN endpoint TxFIFO depth" ]
    pub fn set_ineptxfd(&mut self, value: u16) {
        self.bits.set_range(16u8..32u8, value as u32);
    }
}
